//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::deserialize_checked;

use crate::instructions::{
    AddAuthorityV1 as AddAuthorityV1IxAccounts, CreateSessionV1 as CreateSessionV1IxAccounts,
    CreateSubAccountV1 as CreateSubAccountV1IxAccounts, CreateV1 as CreateV1IxAccounts,
    MigrateToWalletAddressV1 as MigrateToWalletAddressV1IxAccounts,
    RemoveAuthorityV1 as RemoveAuthorityV1IxAccounts, SignV1 as SignV1IxAccounts,
    SignV2 as SignV2IxAccounts, SubAccountSignV1 as SubAccountSignV1IxAccounts,
    ToggleSubAccountV1 as ToggleSubAccountV1IxAccounts,
    TransferAssetsV1 as TransferAssetsV1IxAccounts,
    UpdateAuthorityV1 as UpdateAuthorityV1IxAccounts,
    WithdrawFromSubAccountV1 as WithdrawFromSubAccountV1IxAccounts,
};
use crate::ID;

/// Swig Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum SwigProgramIx {
    CreateV1(CreateV1IxAccounts),
    AddAuthorityV1(AddAuthorityV1IxAccounts),
    RemoveAuthorityV1(RemoveAuthorityV1IxAccounts),
    UpdateAuthorityV1(UpdateAuthorityV1IxAccounts),
    SignV1(SignV1IxAccounts),
    SignV2(SignV2IxAccounts),
    CreateSessionV1(CreateSessionV1IxAccounts),
    CreateSubAccountV1(CreateSubAccountV1IxAccounts),
    WithdrawFromSubAccountV1(WithdrawFromSubAccountV1IxAccounts),
    SubAccountSignV1(SubAccountSignV1IxAccounts),
    ToggleSubAccountV1(ToggleSubAccountV1IxAccounts),
    MigrateToWalletAddressV1(MigrateToWalletAddressV1IxAccounts),
    TransferAssetsV1(TransferAssetsV1IxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;

    #[cfg(not(feature = "shared-data"))]
    type Output = SwigProgramIx;

    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<SwigProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "Swig::InstructionParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 1] = ix_update.data[0..1].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);

        let ix_discriminator: [u8; 1] = ix.data[0..1].try_into()?;
        let ix_data = &ix.data[1..];
        let ix = match ix_discriminator {
            [0] => {
                let expected_accounts_len = 4;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    swig_wallet_address: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::CreateV1(ix_accounts))
            }
            [1] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = AddAuthorityV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::AddAuthorityV1(ix_accounts))
            }
            [2] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RemoveAuthorityV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::RemoveAuthorityV1(ix_accounts))
            }
            [3] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateAuthorityV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::UpdateAuthorityV1(ix_accounts))
            }
            [4] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SignV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::SignV1(ix_accounts))
            }
            [11] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SignV2IxAccounts {
                    swig: next_account(accounts)?,
                    swig_wallet_address: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::SignV2(ix_accounts))
            }
            [5] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateSessionV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::CreateSessionV1(ix_accounts))
            }
            [6] => {
                let expected_accounts_len = 4;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateSubAccountV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    sub_account: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::CreateSubAccountV1(ix_accounts))
            }
            [7] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = WithdrawFromSubAccountV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    sub_account: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    swig_wallet_address: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::WithdrawFromSubAccountV1(ix_accounts))
            }
            [9] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SubAccountSignV1IxAccounts {
                    swig: next_account(accounts)?,
                    sub_account: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::SubAccountSignV1(ix_accounts))
            }
            [10] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ToggleSubAccountV1IxAccounts {
                    swig: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    sub_account: next_account(accounts)?,
                };
                Ok(SwigProgramIx::ToggleSubAccountV1(ix_accounts))
            }
            [12] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = MigrateToWalletAddressV1IxAccounts {
                    swig: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    swig_wallet_address: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::MigrateToWalletAddressV1(ix_accounts))
            }
            [13] => {
                let expected_accounts_len = 4;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = TransferAssetsV1IxAccounts {
                    swig: next_account(accounts)?,
                    swig_wallet_address: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(SwigProgramIx::TransferAssetsV1(ix_accounts))
            }
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            }
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use super::{InstructionParser, SwigProgramIx};
    use crate::proto_def;
    use yellowstone_vixen_core::proto_helper_traits;
    proto_helper_traits!();
    use yellowstone_vixen_core::proto::ParseProto;

    use super::CreateV1IxAccounts;
    impl IntoProto<proto_def::CreateV1IxAccounts> for CreateV1IxAccounts {
        fn into_proto(self) -> proto_def::CreateV1IxAccounts {
            proto_def::CreateV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                swig_wallet_address: self.swig_wallet_address.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::AddAuthorityV1IxAccounts;
    impl IntoProto<proto_def::AddAuthorityV1IxAccounts> for AddAuthorityV1IxAccounts {
        fn into_proto(self) -> proto_def::AddAuthorityV1IxAccounts {
            proto_def::AddAuthorityV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::RemoveAuthorityV1IxAccounts;
    impl IntoProto<proto_def::RemoveAuthorityV1IxAccounts> for RemoveAuthorityV1IxAccounts {
        fn into_proto(self) -> proto_def::RemoveAuthorityV1IxAccounts {
            proto_def::RemoveAuthorityV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::UpdateAuthorityV1IxAccounts;
    impl IntoProto<proto_def::UpdateAuthorityV1IxAccounts> for UpdateAuthorityV1IxAccounts {
        fn into_proto(self) -> proto_def::UpdateAuthorityV1IxAccounts {
            proto_def::UpdateAuthorityV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::SignV1IxAccounts;
    impl IntoProto<proto_def::SignV1IxAccounts> for SignV1IxAccounts {
        fn into_proto(self) -> proto_def::SignV1IxAccounts {
            proto_def::SignV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::SignV2IxAccounts;
    impl IntoProto<proto_def::SignV2IxAccounts> for SignV2IxAccounts {
        fn into_proto(self) -> proto_def::SignV2IxAccounts {
            proto_def::SignV2IxAccounts {
                swig: self.swig.to_string(),
                swig_wallet_address: self.swig_wallet_address.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateSessionV1IxAccounts;
    impl IntoProto<proto_def::CreateSessionV1IxAccounts> for CreateSessionV1IxAccounts {
        fn into_proto(self) -> proto_def::CreateSessionV1IxAccounts {
            proto_def::CreateSessionV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateSubAccountV1IxAccounts;
    impl IntoProto<proto_def::CreateSubAccountV1IxAccounts> for CreateSubAccountV1IxAccounts {
        fn into_proto(self) -> proto_def::CreateSubAccountV1IxAccounts {
            proto_def::CreateSubAccountV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                sub_account: self.sub_account.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::WithdrawFromSubAccountV1IxAccounts;
    impl IntoProto<proto_def::WithdrawFromSubAccountV1IxAccounts>
        for WithdrawFromSubAccountV1IxAccounts
    {
        fn into_proto(self) -> proto_def::WithdrawFromSubAccountV1IxAccounts {
            proto_def::WithdrawFromSubAccountV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                sub_account: self.sub_account.to_string(),
                authority: self.authority.to_string(),
                swig_wallet_address: self.swig_wallet_address.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::SubAccountSignV1IxAccounts;
    impl IntoProto<proto_def::SubAccountSignV1IxAccounts> for SubAccountSignV1IxAccounts {
        fn into_proto(self) -> proto_def::SubAccountSignV1IxAccounts {
            proto_def::SubAccountSignV1IxAccounts {
                swig: self.swig.to_string(),
                sub_account: self.sub_account.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::ToggleSubAccountV1IxAccounts;
    impl IntoProto<proto_def::ToggleSubAccountV1IxAccounts> for ToggleSubAccountV1IxAccounts {
        fn into_proto(self) -> proto_def::ToggleSubAccountV1IxAccounts {
            proto_def::ToggleSubAccountV1IxAccounts {
                swig: self.swig.to_string(),
                payer: self.payer.to_string(),
                sub_account: self.sub_account.to_string(),
            }
        }
    }
    use super::MigrateToWalletAddressV1IxAccounts;
    impl IntoProto<proto_def::MigrateToWalletAddressV1IxAccounts>
        for MigrateToWalletAddressV1IxAccounts
    {
        fn into_proto(self) -> proto_def::MigrateToWalletAddressV1IxAccounts {
            proto_def::MigrateToWalletAddressV1IxAccounts {
                swig: self.swig.to_string(),
                authority: self.authority.to_string(),
                payer: self.payer.to_string(),
                swig_wallet_address: self.swig_wallet_address.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::TransferAssetsV1IxAccounts;
    impl IntoProto<proto_def::TransferAssetsV1IxAccounts> for TransferAssetsV1IxAccounts {
        fn into_proto(self) -> proto_def::TransferAssetsV1IxAccounts {
            proto_def::TransferAssetsV1IxAccounts {
                swig: self.swig.to_string(),
                swig_wallet_address: self.swig_wallet_address.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for SwigProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                SwigProgramIx::CreateV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateV1(
                        proto_def::CreateV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::AddAuthorityV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::AddAuthorityV1(
                        proto_def::AddAuthorityV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::RemoveAuthorityV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveAuthorityV1(
                        proto_def::RemoveAuthorityV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::UpdateAuthorityV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateAuthorityV1(
                        proto_def::UpdateAuthorityV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::SignV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SignV1(
                        proto_def::SignV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::SignV2(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SignV2(
                        proto_def::SignV2Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::CreateSessionV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateSessionV1(
                        proto_def::CreateSessionV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::CreateSubAccountV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateSubAccountV1(
                        proto_def::CreateSubAccountV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::WithdrawFromSubAccountV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::WithdrawFromSubAccountV1(
                        proto_def::WithdrawFromSubAccountV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::SubAccountSignV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SubAccountSignV1(
                        proto_def::SubAccountSignV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::ToggleSubAccountV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ToggleSubAccountV1(
                        proto_def::ToggleSubAccountV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::MigrateToWalletAddressV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::MigrateToWalletAddressV1(
                        proto_def::MigrateToWalletAddressV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                SwigProgramIx::TransferAssetsV1(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::TransferAssetsV1(
                        proto_def::TransferAssetsV1Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
